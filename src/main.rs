#![feature(string_remove_matches)]

mod defs;
use dashmap::DashMap;
use defs::{
    OUTPUT_SCRIPT_CODE_DIR, 
    SOURCE_XLSXS_DIR, 
    DEFAULT_SOURCE_SUFFIX, 
    DEFAULT_DEST_SUFFIX, REF_TEXT_DIR, OUTPUT_ENUM_CODE_DIR, LINE_END_FLAG
};

mod parser;
mod reference;

mod args;
use args::Args;
use clap::Parser;
use lazy_static::lazy_static;
use reference::RefData;
use xlsx_read::excel_file::ExcelFile;
use xlsx_read::excel_table::ExcelTable;

use std::collections::{HashSet, BTreeMap};
use std::fs::File;
use std::io::Write;
use std::rc::Rc;
use std::sync::{Arc, Mutex};
use std::{fs, thread};
use std::path::Path;
use std::process::exit;

use crate::parser::CellValue;

type ThreadHandles = Arc<Mutex<Vec<thread::JoinHandle<()>>>>;
type RefDataMap = DashMap<String, Arc<RefData>>;

fn process_xlsx_dir<P: AsRef<Path>>(dir: P) -> Result<(), std::io::Error> {
    for entry in fs::read_dir(dir)? {
        let path = entry?.path();
        if path.is_dir() {
            //process_xlsx_dir(path)?;
            let handle = thread::spawn(|| {
                let _ = process_xlsx_dir(path);
            });
            HANDLES.lock().unwrap().push(handle);
        } else if path.extension().is_some_and(|x| x.to_str().unwrap() == DEFAULT_SOURCE_SUFFIX) && !path.starts_with("~") {
            let base_name = path.file_name().unwrap().to_str().unwrap();
            if FILE_NAME_FILTER.contains(base_name) {
                continue;
            }
            let idx = base_name.find('.').unwrap_or_default();
            
            if base_name == "LString.xlsx" {
                // async
                process_lstring_xlsx(path.clone());
            } else if base_name == "GlobalConfig.xlsx" {
                // sync
                process_global_config(&path, &base_name[..idx]);
            } else {
                let mut parser = parser::Parser::new();
                if let Some(refdata) = RefData::new(REF_TEXT_DIR, &base_name[..idx]) {
                    let aref = Arc::from(refdata);
                    if !RDM.contains_key(&base_name[..idx]) {
                        RDM.insert(String::from(&base_name[..idx]), aref.clone());
                    }
                    parser.read_file(&base_name[..idx], &path, Some(aref))?;
                } else {
                    parser.read_file(&base_name[..idx], &path, None)?;
                }

                let output_path = format!("{}/{}.{}", OUTPUT_SCRIPT_CODE_DIR, &base_name[..idx], DEFAULT_DEST_SUFFIX);
                let mut file = File::create(output_path)?;
                println!("Process file_name: {}", base_name);
                parser.generate("\r\n", &mut file)?;
            }
        }
    }
    Ok(())
}

#[allow(unused_must_use)]
fn process_global_config<P: AsRef<Path>>(path: P, name: &str) {
    let file = ExcelFile::load_from_path(path);
    if let Ok(mut ff) = file {
        match ff.parse_workbook() {
            Ok(ret) => {
                let output_path = format!("{}/{}.{}", OUTPUT_SCRIPT_CODE_DIR, "GlobalConfig", DEFAULT_DEST_SUFFIX);
                if let Ok(mut file) = File::create(output_path) {
                    writeln!(file, "////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////");
                    writeln!(file, "// This File is generated by the program, DO NOT EDIT MANUALLY!");
                    writeln!(file, "// 此文件由程序生成, 切勿手动编辑!");
                    writeln!(file, "////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////");
                    writeln!(file, "using Config;");
                    writeln!(file, "using System.Collections.Generic;");
                    writeln!(file, "using Config.Common;");
                    writeln!(file, "");
                    writeln!(file, "#pragma warning disable 1591");
                    writeln!(file, "");
                    writeln!(file, "[System.Serializable]");
                    writeln!(file, "public class {} : IConfigData", name);
                    writeln!(file, "{{");
                    writeln!(file, "\tpublic int GetItemId(string refName) => throw new System.NotImplementedException();");
                    writeln!(file, "\tpublic int AddExtraItem(string identifier, string refName, object configItem) => throw new System.NotImplementedException();");
                    writeln!(file, "\tpublic static {} Instance = new {}();", name, name);
                    writeln!(file, "");

                    
                    for (_, id) in ret.into_iter() {
                        if let Ok(table) = ff.parse_sheet(*id) {
                            let height = table.height();
                            let mut vals = Vec::<(Rc<String>, CellValue)>::with_capacity(height);

                            for row in 1..height {
                                if let (Some(ident), Some(ty), Some(val), Some(desc), Some(modify)) = (
                                    table.cell(0, row),
                                    table.cell(1, row),
                                    table.cell(2, row),
                                    table.cell(3, row),
                                    table.cell(4, row)
                                ) {
                                    writeln!(file, "\t/// <summary>");
                                    writeln!(file, "\t/// {}", desc);
                                    writeln!(file, "\t/// </summary>");
                                    
                                    let cell = CellValue::new(val, ty, &Rc::default(), &BTreeMap::default(), ident, &Rc::default(), name, 0, 0);
                                    if modify.as_str() == "0" {
                                        write!(file, "\tpublic {} {} = ", ty, ident);
                                        cell.gen_code(&mut file);
                                        writeln!(file, ";");
                                    } else if cell.is_arr_or_list() {
                                        write!(file, "\tpublic static readonly {} {} = ", ty, ident);
                                        cell.gen_code(&mut file);
                                        writeln!(file, ";");
                                    } else {
                                        write!(file, "\tpublic const {} {} = ", ty, ident);
                                        cell.gen_code(&mut file);
                                        writeln!(file, ";");
                                    }

                                    vals.push((ident.clone(), cell));
                                }
                            }

                            writeln!(file, "");
                            writeln!(file, "\tpublic void Init()");
                            writeln!(file, "\t{{");
                            for (ident, cell) in vals.iter() {
                                write!(file, "\t\t{} = ", ident);
                                cell.gen_code(&mut file);
                                writeln!(file, ";");
                            }
                            writeln!(file, "\t}}");
                            write!(file, "}}");
                        }
                    }
                }
            }
            _ => {}
        }
    }
}

#[allow(unused_must_use)]
fn process_lstring_xlsx<P: AsRef<Path> + std::marker::Send + 'static>(path: P) {
    let handle = thread::spawn(|| {
        let file = ExcelFile::load_from_path(path);
        let mut tables = Vec::<ExcelTable>::default();

        if let Ok(mut ff) = file {
            match ff.parse_workbook() {
                Ok(ret) => {
                    let output_path = format!("{}/{}.{}", OUTPUT_SCRIPT_CODE_DIR, "LanguageKey", DEFAULT_DEST_SUFFIX);
                    if let Ok(mut file) = File::create(output_path) {
                        writeln!(file, "////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////");
                        writeln!(file, "// This File is generated by the program, DO NOT EDIT MANUALLY!");
                        writeln!(file, "// 此文件由程序生成, 切勿手动编辑!");
                        writeln!(file, "////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////");
                        writeln!(file, "using System.Collections.Generic;");
                        writeln!(file, "// ReSharper disable InconsistentNaming");
                        writeln!(file, "// ReSharper disable IdentifierTypo");
                        writeln!(file, "// ReSharper disable StringLiteralTypo");
                        writeln!(file, "public class LanguageKey");
                        writeln!(file, "{{");
                        writeln!(file, "#region const keys");

                        for (_, id) in ret.into_iter() {
                            if let Ok(table) = ff.parse_sheet(*id) {
                                tables.push(table);
                            }
                        }

                        let mut count = 0;
                        for table in tables.iter() {
                            let height = table.height();
                            for row in 2..height {
                                table.cell(0, row).map(|v| {
                                    writeln!(file, "\tpublic const ushort {} = {};", v, count);
                                    count += 1;
                                });
                            }
                        }

                        writeln!(file, "\tpublic const ushort Invalid = ushort.MaxValue;");
                        writeln!(file, "#endregion");
                        writeln!(file, "");
                        writeln!(file, "\tpublic static ushort LanguageKeyToId(string languageKey)");
                        writeln!(file, "\t\tif (_filedIdMap.TryGetValue(languageKey, out ushort id))");
                        writeln!(file, "\t\t\treturn id;");
                        writeln!(file, "\t\treturn Invalid;");
                        writeln!(file, "\t}}");
                        writeln!(file, "");

                        writeln!(file, "\tprivate static readonly Dictionary<string,ushort> _filedIdMap = new Dictionary<string,ushort>()");
                        writeln!(file, "\t{{");
                        for table in tables.iter() {
                            let height = table.height();
                            for row in 2..height {
                                table.cell(0, row).map(|v| {
                                    writeln!(file, "\t\t{{\"{}\", {}}},", v, v);
                                });
                            }
                        }
                        writeln!(file, "\t}};");
                        writeln!(file, "}}");
                    }
                }
                _ => {}
            }
        }
    });

    HANDLES.lock().unwrap().push(handle);
}

lazy_static! (
    static ref HANDLES: ThreadHandles = Arc::new(Mutex::new(Vec::new()));
    static ref RDM: RefDataMap = DashMap::default();
    static ref FILE_NAME_FILTER: HashSet<&'static str> = {
        let mut ret = HashSet::<&'static str>::default();
        ret.insert("NameCore_CN.xlsx");
        ret.insert("DeadCharacter.xlsx");
        ret.insert("InscribedCharacter.xlsx");
        ret
    };
);

fn main() {
    let args = Args::parse();

    match args.command {
        args::Command::Build => {
            if let Err(_) = fs::metadata(OUTPUT_SCRIPT_CODE_DIR) {
                if let Err(_) = fs::create_dir_all(OUTPUT_SCRIPT_CODE_DIR) {
                    exit(-1)
                }
            }
            
            if let Err(_) = fs::metadata(OUTPUT_ENUM_CODE_DIR) {
                if let Err(_) = fs::create_dir_all(OUTPUT_ENUM_CODE_DIR) {
                    exit(-1)
                }
            }

            if args.name.is_empty() {
                if let Err(e) = process_xlsx_dir(SOURCE_XLSXS_DIR) {
                    println!("{}", e);
                    exit(-1); 
                }

                for handle in HANDLES.lock().unwrap().drain(..) {
                    let _ = handle.join();
                }
            } else {
                let base_name = args.name;
                let mut file_name = String::from(&base_name);
                file_name.push('.');
                file_name.push_str(DEFAULT_SOURCE_SUFFIX);
                let xlsx_path = parser::find_file(SOURCE_XLSXS_DIR, &file_name);

                let mut parser = parser::Parser::new();

                if let Some(refdata) = RefData::new(REF_TEXT_DIR, &base_name) {
                    if let Err(e) = parser.read_file(&base_name, xlsx_path, Some(Arc::from(refdata))) {
                        println!("{}", e);
                        exit(-1);
                    }
                } else {
                    if let Err(e) = parser.read_file(&base_name, xlsx_path, None) {
                        println!("{}", e);
                        exit(-1);
                    }
                }

                let output_path = format!("{}/{}.{}", OUTPUT_SCRIPT_CODE_DIR, base_name, DEFAULT_DEST_SUFFIX);
                if let Ok(mut file) = File::create(output_path) {
                    if let Err(e) = parser.generate(LINE_END_FLAG, &mut file) {
                        println!("{}", e);
                        exit(-1)
                    }
                } else {
                    exit(-1)
                }
            }
        },
        args::Command::Clean => {
            if let Err(e) = fs::remove_dir_all(OUTPUT_SCRIPT_CODE_DIR) {
                println!("{}", e);
                exit(-1)
            }
            if let Err(e) = fs::remove_dir_all(OUTPUT_ENUM_CODE_DIR) {
                println!("{}", e);
                exit(-1)
            }
        },
    }

    exit(0)
}